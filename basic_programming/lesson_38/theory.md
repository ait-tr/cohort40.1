# Lesson 38


Внутренние классы (Inner Classes) в Java представляют собой классы, объявленные внутри других классов. Они могут быть очень полезными для логической группировки классов, которые используются только в одном контексте, увеличивая инкапсуляцию. Внутренние классы бывают нескольких видов:

### 1. Нестатические вложенные классы (Non-static Nested Classes) или Внутренние классы (Inner Classes)
Эти классы связаны с экземпляром внешнего класса. Они могут обращаться к членам внешнего класса, включая закрытые (private) члены.

```java
public class OuterClass {
    private int value = 10;

    class InnerClass {
        public int getValue() {
            return value;
        }
    }
}
```

### 2. Статические вложенные классы (Static Nested Classes)
Эти классы связаны с внешним классом, а не с его экземпляром. Они могут обращаться только к статическим членам внешнего класса.

```java
public class OuterClass {
    private static int value = 10;

    static class StaticNestedClass {
        public int getValue() {
            return value;
        }
    }
}
```

### 3. Локальные классы (Local Classes)
Локальные классы объявляются в блоках кода, обычно в методах. Они видимы только внутри блока, где они объявлены.

```java
public class OuterClass {
    public void display() {
        class LocalClass {
            void print() {
                System.out.println("Внутри локального класса");
            }
        }

        LocalClass localClass = new LocalClass();
        localClass.print();
    }
}
```

### 4. Анонимные классы (Anonymous Classes)
Это классы без имени, объявляемые и одновременно создающие экземпляр. Они полезны для создания быстрых реализаций интерфейсов или суперклассов.

```java
public class OuterClass {
    public void display() {
        new InterfaceName() {
            @Override
            public void method() {
                // реализация
            }
        }.method();
    }
}
```

### Преимущества использования внутренних классов:
- Повышение инкапсуляции и связности кода.
- Возможность доступа к частным членам внешнего класса.
- Удобство в создании небольших вспомогательных классов.
- Локальные и анонимные классы могут облегчить реализацию сложных интерфейсов или подклассов.

### Недостатки:
- Усложнение структуры кода и возможность снижения его читаемости, особенно при злоупотреблении внутренними классами.
- Возможные проблемы с сериализацией объектов внутренних классов.


Анонимные классы в Java — это специальный вид внутренних классов, не имеющих имени. Они используются для создания объектов с немедленной реализацией или расширением существующих классов или реализации интерфейсов. Анонимные классы удобны для создания быстрых решений, когда нужна реализация только одного метода или для реализации интерфейсов в месте их использования.

### Основные характеристики анонимных классов:

1. **Безымянные:**
    - У анонимных классов нет имени, что означает, что их нельзя повторно использовать в другом месте кода.

2. **Объявление и создание одновременно:**
    - Анонимный класс объявляется и инстанциируется в одной конструкции, обычно при вызове метода или создании объекта.

3. **Только один экземпляр:**
    - Создается только один экземпляр анонимного класса, и он не может быть повторно инстанциирован в другом месте.

4. **Может расширять класс или реализовать интерфейс:**
    - Анонимные классы могут расширять существующие классы или реализовывать интерфейсы.

5. **Доступ к final переменным:**
    - Анонимные классы могут использовать final локальные переменные из области, в которой они были созданы.

### Пример использования анонимного класса:

```java
interface Greeting {
    void greet();
}

public class Test {
    public static void main(String[] args) {
        // Создание анонимного класса, реализующего интерфейс Greeting
        Greeting greeting = new Greeting() {
            @Override
            public void greet() {
                System.out.println("Привет, мир!");
            }
        };

        greeting.greet(); // Вызов метода greet
    }
}
```

В этом примере создается анонимный класс, который реализует интерфейс `Greeting`. Этот анонимный класс предоставляет реализацию метода `greet`.

### Применение анонимных классов:

Анонимные классы часто используются в графических интерфейсах, например, для обработки событий, а также в различных сценариях, где требуется небольшая, одноразовая реализация интерфейса или расширение класса. Однако с появлением лямбда-выражений в Java 8 их использование стало менее популярным, поскольку лямбда-выражения предоставляют более краткий и удобный способ реализации функциональных интерфейсов.

В Java "функциональный интерфейс" - это интерфейс, который содержит только один абстрактный метод. Функциональные интерфейсы были введены в Java 8 вместе с функциональными выражениями, которые позволяют использовать лямбда-выражения для создания экземпляров таких интерфейсов. Этот концепт был введен для поддержки программирования в стиле функционального программирования и упрощения работы с анонимными функциями.

Один из наиболее известных функциональных интерфейсов в Java - это `java.util.function.Predicate`, который определяет метод `test()`. Вот пример использования этого интерфейса:

```java
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        Predicate<Integer> isPositive = (num) -> num > 0;

        System.out.println(isPositive.test(5));  // Вывод: true
        System.out.println(isPositive.test(-5)); // Вывод: false
    }
}
```

Функциональные интерфейсы могут содержать и другие методы помимо одного абстрактного метода, но для того чтобы считаться функциональными, они должны иметь аннотацию `@FunctionalInterface`. Эта аннотация помогает компилятору проверить, что интерфейс соответствует требованиям функционального интерфейса и имеет только один абстрактный метод.

Лямбда-выражения (или лямбда-функции) - это способ представления анонимных функций в программировании. Лямбда-выражения позволяют вам создавать и передавать функции как аргументы другим функциям, а также использовать их в качестве выражений, что делает код более компактным и читаемым. Основная идея лямбда-выражений заключается в том, чтобы позволить определить функцию "на месте" без явного объявления имени для неё.

В Java лямбда-выражения были введены в версии 8 и связаны с использованием функциональных интерфейсов. Лямбда-выражение в Java имеет следующий синтаксис:

```java
(parameters) -> expression
```

где:
- `parameters` - параметры функции (если они есть). Если функция не принимает параметры, то они могут быть опущены, например, `() -> expression`.
- `expression` - тело функции, которое выполняется при вызове лямбда-выражения.

Примеры использования лямбда-выражений в Java:

```java
// Пример 1: Лямбда-выражение без параметров
Runnable runnable = () -> System.out.println("Hello, World!");
runnable.run();

// Пример 2: Лямбда-выражение с параметрами
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
int result = add.apply(5, 3); // result содержит 8

// Пример 3: Лямбда-выражение как аргумент функции
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println("Hello, " + name));
```

Лямбда-выражения делают код более кратким и уменьшают необходимость в объявлении анонимных классов при работе с интерфейсами, которые имеют только один абстрактный метод (такие интерфейсы называются функциональными интерфейсами).


