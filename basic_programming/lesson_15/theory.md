# Lesson 15

### Линейный поиск

Линейный поиск — это простой алгоритм поиска, который итерирует через все элементы в массиве, проверяя каждый элемент на соответствие искомому значению. Если элемент найден, алгоритм возвращает его индекс. Если элемент не найден до конца массива, возвращается `-1`, указывая на то, что элемент отсутствует в массиве. Вот пример реализации линейного поиска на Java:

```java
public class LinearSearch {

    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Возвращаем индекс найденного элемента
            }
        }
        return -1; // Элемент не найден
    }

    public static void main(String[] args) {
        int[] arr = {3, 45, 1, 2, 8, 19}; // Пример массива
        int target = 8; // Элемент, который мы хотим найти

        int result = linearSearch(arr, target);

        if (result == -1) {
            System.out.println("Элемент не найден в массиве.");
        } else {
            System.out.println("Элемент найден на позиции: " + result);
        }
    }
}
```

В этом примере метод `linearSearch` принимает массив `arr` и искомое значение `target`. Метод проходит по массиву от начала до конца, сравнивая каждый элемент с `target`. Если совпадение найдено, метод немедленно возвращает индекс этого элемента. Если после проверки всех элементов совпадение не найдено, метод возвращает `-1`, указывая на отсутствие элемента в массиве.

Линейный поиск особенно эффективен для небольших или неотсортированных массивов, где применение более сложных алгоритмов поиска, таких как бинарный поиск, не оправдано из-за их предварительных требований (например, необходимость сортировки массива).


### Бинарный поиск

Бинарный поиск — это эффективный алгоритм поиска, который использует принцип деления пополам для нахождения элемента в отсортированном массиве. Этот метод значительно ускоряет поиск по сравнению с линейным поиском, особенно для больших массивов, так как количество сравнений сокращается с линейного до логарифмического.

### Принцип работы

1. **Инициализация:** Определите два указателя — начало (`left`) и конец (`right`) массива, которые обозначают границы поиска.
2. **Нахождение среднего элемента:** На каждом шаге алгоритма вычислите индекс среднего элемента (`mid`) как `(left + right) / 2`.
3. **Сравнение среднего элемента с искомым значением:**
    - Если средний элемент равен искомому (`target`), поиск завершается успешно.
    - Если средний элемент меньше `target`, сужаем область поиска к правой половине, устанавливая `left` на `mid + 1`.
    - Если средний элемент больше `target`, сужаем область поиска к левой половине, устанавливая `right` на `mid - 1`.
4. **Повторение:** Повторяйте шаги 2 и 3, пока `left` не станет больше `right`.
5. **Завершение поиска:** Если искомый элемент найден, возвращается его индекс. Если же область поиска исчерпана, и элемент не найден, возвращается `-1`.

### Сложность

Бинарный поиск имеет временную сложность O(log n), где n — количество элементов в массиве. Это делает его невероятно эффективным для поиска в больших массивах.

### Примечания

- Бинарный поиск применим только к отсортированным массивам или коллекциям. Если массив не отсортирован, его сначала необходимо отсортировать, что может увеличить общую временную сложность операции поиска.
- Бинарный поиск может быть реализован как в итеративной, так и в рекурсивной форме. Итеративный подход обычно предпочтительнее с точки зрения использования памяти, так как он избегает дополнительного стека вызовов, требуемого для рекурсии.


