# Lesson 28

Метод `hashcode()` в Java является частью класса `Object`, от которого наследуются все классы. Метод `hashCode()` используется для получения хэш-кода объекта, который представляет собой целое число. Хэш-коды часто используются в Java для улучшения производительности хранения и поиска объектов в структурах данных, основанных на хеш-таблицах, таких как `HashSet`, `HashMap`, `HashTable` и другие.

### Важные аспекты метода `hashCode()`:

- **Контракт `hashCode()`:** Java определяет определённый контракт между методами `hashCode()` и `equals()`. Если два объекта считаются равными по методу `equals()`, то вызов метода `hashCode()` должен возвращать одинаковое целое значение для этих объектов. Однако обратное не обязательно верно: два объекта с одинаковыми хэш-кодами не обязательно должны быть равны по методу `equals()`.

- **Производительность:** Хорошая реализация `hashCode()` должна стремиться распределять результаты равномерно по всему диапазону `int`, чтобы минимизировать количество коллизий в хеш-таблице. Коллизия происходит, когда два объекта возвращают одинаковый хэш-код.

- **Переопределение `hashCode()`:** При переопределении метода `equals()` для изменения критериев равенства объектов также следует переопределить метод `hashCode()`, чтобы поддерживать контракт между `hashCode()` и `equals()`. Несоблюдение этого правила может привести к неправильному поведению объектов в коллекциях, основанных на хеш-таблицах.

- **Реализация:** Стандартная реализация `hashCode()` в классе `Object` возвращает различные целые числа для разных объектов, даже если они одинаковы с точки зрения пользователя. Однако классы, такие как `String`, `Integer`, `Date` и многие другие, переопределяют `hashCode()`, чтобы обеспечить более эффективное и справедливое распределение хэш-кодов.

### Пример переопределения `hashCode()`:

Вот простой пример класса, переопределяющего `hashCode()`:

```java
public class Person {
    private String name;
    private int age;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
               Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

В этом примере метод `hashCode()` использует вспомогательный класс `Objects.hash()`, который генерирует хэш-код, основываясь на значении полей `name` и `age`. Это обеспечивает согласованность с методом `equals()`, который также сравнивает эти поля.

Заключение: Правильное использование и переопределение метода `hashCode()` важно для эффективной работы с коллекциями на основе хеш-таблиц в Java. Оно помогает обеспечить быстрый доступ к элементам и улучшает производительность программ на Java.


### Коллекция `HashMap`:

`HashMap` в Java - это часть Java Collections Framework и представляет собой структуру данных, используемую для хранения пар "ключ-значение". 
Она позволяет быстро извлекать и обновлять значения по ключам.

### Основные характеристики `HashMap`:

1. **Пары "Ключ-Значение"**:
    - Каждый элемент в `HashMap` хранится в виде пары "ключ-значение".
    - Ключи уникальны, а значения могут быть дублирующимися.

2. **Быстрый доступ**:
    - `HashMap` предоставляет очень быстрый доступ к элементам. Время доступа к элементу (для поиска, вставки или удаления) приблизительно постоянно, не зависит от количества элементов в `HashMap`.

3. **null значения**:
    - `HashMap` допускает наличие одного `null` в качестве ключа и несколько `null` значений.

4. **Неупорядоченность**:
    - `HashMap` не гарантирует порядок хранения элементов. Порядок может изменяться при добавлении или удалении элементов.

5. **Не синхронизирован**:
    - `HashMap` не синхронизирован, что означает, что она не потокобезопасна. Если несколько потоков одновременно доступаются к `HashMap` и хотя бы один из потоков изменяет её структуру, это должно быть синхронизировано внешним образом.

### Работа `HashMap`:

- **Хеширование**:
    - `HashMap` использует хеш-функцию для вычисления индекса в массиве, где будет храниться пара "ключ-значение". Это обеспечивает быстрый доступ к значению по ключу.

- **Коллизии**:
    - Когда два разных ключа имеют один и тот же хеш-код (так называемая коллизия), `HashMap` использует связанные списки (или деревья в более новых версиях Java) для хранения этих элементов в одной ячейке массива.

- **Вместимость и коэффициент загрузки**:
    - Вместимость `HashMap` - это количество "корзин", доступных для хранения элементов. Коэффициент загрузки - это мера того, насколько полностью `HashMap` должен быть заполнен перед увеличением его размера. При достижении порога вместимости * коэффициента загрузки `HashMap` автоматически увеличивается.

- **Итерация**:
    - Итерация по элементам `HashMap` (ключам, значениям или парах "ключ-значение") не гарантирует определенного порядка.

### Примеры использования:

```java
import java.util.HashMap;

public class Example {
    public static void main(String[] args) {
        // Создание HashMap
        HashMap<String, Integer> map = new HashMap<>();

        // Добавление элементов
        map.put("Apple", 50);
        map.put("Banana", 30);
        map.put("Orange", 20);

        // Получение значения по ключу
        System.out.println("Price of Apple: " + map.get("Apple"));

        // Проверка наличия ключа или значения
        if (map.containsKey("Banana")) {
            System.out.println("Banana is available");
        }

        // Обновление значения
        map.put("Apple", 60);

        // Удаление элемента
        map.remove("Orange");

        // Итерация по HashMap
        for (String key : map.keySet()) {
            System.out.println(key + ": " + map.get(key));
        }
    }
}


```

`HashMap` широко используется из-за своей эффективности и простоты использования, особенно когда требуется быстрый доступ к данным по ключу.

### `HashSet`

`HashSet` в Java является частью Java Collections Framework и представляет собой коллекцию, используемую для хранения уникальных элементов. Он реализует интерфейс `Set` и использует `HashMap` для хранения элементов.

### Основные характеристики `HashSet`:

1. **Уникальность элементов**:
    - `HashSet` хранит только уникальные элементы, то есть не допускает дубликатов.

2. **Быстрый доступ**:
    - `HashSet` обеспечивает быстрый доступ к его элементам. Он использует хеш-код объектов для определения их местоположения в коллекции, что обеспечивает быструю операцию поиска, вставки и удаления.

3. **null значения**:
    - `HashSet` допускает наличие одного `null` элемента.

4. **Неупорядоченность**:
    - `HashSet` не гарантирует сохранение порядка элементов. Элементы располагаются в коллекции в зависимости от их хеш-кодов, что может привести к изменению порядка при добавлении или удалении элементов.

5. **Не синхронизирован**:
    - Как и `HashMap`, `HashSet` не является синхронизированным и не потокобезопасным. Если множество используется несколькими потоками, его следует синхронизировать внешним образом.

### Работа `HashSet`:

- **Хеширование**:
    - При добавлении элемента в `HashSet`, используется его хеш-код для определения места хранения во внутренней структуре `HashMap`. Это позволяет `HashSet` быстро определять, содержит ли он определенный элемент.

- **Коллизии**:
    - Если два элемента имеют одинаковый хеш-код, `HashSet` будет использовать механизм разрешения коллизий для размещения этих элементов.

- **Операции**:
    - Основные операции в `HashSet` включают `add`, `remove`, `contains`, и `size`. Эти операции, как правило, выполняются за постоянное время.

### Примеры использования:

```java
import java.util.HashSet;

public class Example {
    public static void main(String[] args) {
        // Создание HashSet
        HashSet<String> set = new HashSet<>();

        // Добавление элементов
        set.add("Apple");
        set.add("Banana");
        set.add("Orange");

        // Попытка добавить дубликат
        boolean isAdded = set.add("Apple"); // Вернет false, так как "Apple" уже есть в наборе

        // Проверка наличия элемента
        if (set.contains("Banana")) {
            System.out.println("Banana is in the set");
        }

        // Удаление элемента
        set.remove("Orange");

        // Итерация по HashSet
        for (String fruit : set) {
            System.out.println(fruit);
        }
    }
}
```

`HashSet` широко используется в случаях, когда необходимо обеспечить уникальность элементов, и важна скорость доступа к этим элементам. Он особенно полезен в задачах, связанных с наборами данных, где порядок элементов не имеет значения.