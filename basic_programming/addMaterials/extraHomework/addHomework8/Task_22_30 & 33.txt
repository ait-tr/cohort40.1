Пошагово создаём игру крестики нолики.

Дано поле игры крестики нолики размерностью три на три клетки.
Поле представлено двумерным массивом целых чисел, где:
-1 - это пустая клетка,
0 - это клетка в которую сделал ход первый игрок,
1 - это клетка в которую сделал ход второй игрок.

Создайте класс TicTacToe и в этом классе реализуйте
метод для определения является ли данная позиция
победной по горизонталям для указанного игрока.

Метод должен иметь следующую сигнатуру:
public boolean isWinPositionForHorizontals(int[][] field, int playerToCheck).

Поле передаётся в этот метод как первый параметр int[][] field.
Знак игрока (0 или 1) передаётся вторым параметром: int playerToCheck.

Метод должет вернуть:
 - true если в одной из горизонталей есть три подряд клетки
   занятые знаком указанного игрока (int playerToCheck),
 - false иначе.

Создать класс TicTacToeTest
и написать тесты для разработанного метода.

------

Пошагово создаём игру крестики нолики.

В классе TicTacToe реализуйте
метод для определения является ли данная позиция
победной по вертикалям для указанного игрока.

Метод должен иметь следующую сигнатуру:
public boolean isWinPositionForVerticals(int[][] field, int playerToCheck).

Поле передаётся в этот метод как первый параметр int[][] field.
Знак игрока (0 или 1) передаётся вторым параметром: int playerToCheck.

Метод должет вернуть:
 - true если в одной из вертикалей есть три подряд клетки
   занятые знаком указанного игрока (int playerToCheck),
 - false иначе.

В классе TicTacToeTest написать тесты для разработанного метода.

--------

Пошагово создаём игру крестики нолики.

В классе TicTacToe реализуйте
метод для определения является ли данная позиция
победной по диагоналям для указанного игрока.

Метод должен иметь следующую сигнатуру:
public boolean isWinPositionForDiagonals(int[][] field, int playerToCheck).

Поле передаётся в этот метод как первый параметр int[][] field.
Знак игрока (0 или 1) передаётся вторым параметром: int playerToCheck.

Метод должет вернуть:
 - true если в одной из диагоналей есть три подряд клетки
   занятые знаком указанного игрока (int playerToCheck),
 - false иначе.

В классе TicTacToeTest написать тесты для разработанного метода.

---------

Пошагово создаём игру крестики нолики.

В классе TicTacToe реализуйте
метод для определения является ли данная позиция
победной для указанного игрока.

Подсказка: победной позиция является тогда, когда
позиция победна по горизонталям ИЛИ вертикалям ИЛИ диагоналям.
Для реализации этого метода воспользуйтесь методами созданными
ранее. Прочувствуйте как просто собирать решение более сложной
задачи из небольших методов.

Метод должен иметь следующую сигнатуру:
public boolean isWinPosition(int[][] field, int playerToCheck).

Поле передаётся в этот метод как первый параметр int[][] field.
Знак игрока (0 или 1) передаётся вторым параметром: int playerToCheck.

Метод должет вернуть:
 - true если позиция победна для указанного игрока (int playerToCheck),
 - false иначе.

В классе TicTacToeTest написать тесты для разработанного метода.

----------

Пошагово создаём игру крестики нолики.

В классе TicTacToe реализуйте
метод для определения является ли данная позиция ничейной.

Подсказка: ничейной позиция является тогда, когда
позиция не победна ни для одного из игроков и нет ни
одной пустой клетки (клетки в которой стоит -1).

Метод должен иметь следующую сигнатуру:
public boolean isDrawPosition(int[][] field).

Поле передаётся в этот метод как первый параметр int[][] field.

Метод должет вернуть:
 - true если позиция ничейна,
 - false иначе.

В классе TicTacToeTest написать тесты для разработанного метода.

---------

Пошагово создаём игру крестики нолики.

В классе TicTacToe реализуйте метод:

public int[][] createField().

Метод должен создавать двумерный массив целых чисел
и вставлять в каждую ячейку массива -1 (признак пустой клетки).

В классе TicTacToeTest написать тесты для разработанного метода.

--------

Пошагово создаём игру крестики нолики.

Создайте класс Move с двумя свойствами:

    private int x;
    private int y;

и конструктором, который принимает два целых числа
- координаты клетки в которую хочет походить игрок
и get методами для этих свойств.

В классе TicTacToe создайте метод:

public Move getNextMove() {
    // запросите у пользователя с консоли две координаты
    // клетки куда хочет походить игрок
    // создайте экземпляр класса Move и передайте ему
    // в конструктор введённые пользователем координаты
    // верните созданный объект Move из метода.
}


--------

Пошагово создаём игру крестики нолики.

Создайте в классе TicTacToe метод:

public void printFieldToConsole(int[][] field) {
    // распечатайте поле на консоль в читаемом формате
}

----------

Пошагово создаём игру крестики нолики.

В классе TicTacToe реализуйте метод:

public void play() {
    int[][] field = createField();
    while(true) {
        printFieldToConsole(field);
        Move move0 = getNextMove();
        field[move0.getX()][move0.getY()] = 0;
        printFieldToConsole(field);
        if (isWin(field, 0)) {
            System.out.println("Player 0 WIN!");
            break;
        }
        if (isDraw(field)) {
            System.out.println("DRAW!");
            break;
        }

        printFieldToConsole(field);
        Move move1 = getNextMove();
        field[move1.getX()][move1.getY()] = 1;
        printFieldToConsole(field);
        if (isWin(field, 1)) {
            System.out.println("Player 1 WIN!");
            break;
        }
        if (isDraw(field)) {
            System.out.println("DRAW!");
            break;
        }
    }
}

Создайте main метод и запустите игру крестики нолики:

public static void main(String[] args) {
    TicTacToe game = new TicTacToe();
    game.play();
}

Сыграйте в игру крестики нолики!

------

Создать простой искуственный интеллект (компьютерного игрока)
для игры в крестики нолики.
Искусственный интеллект можно реализовать
так, что он будет выбирать случайную пустую клетку
для того, чтобы сделать ход. А можно научить компьютер распознавать
выигрышные комбинации в один ход и выигрывать, а
так же защищаться от проигрыша в один ход если это
возможно.