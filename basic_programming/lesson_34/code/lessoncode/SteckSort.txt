Стек MAIN ( 18, 4, 39)
Стек допстек ()

Сортировка:
1 шаг: temp = 18
        проверяем что допстек непустой и его вершина > temp
        поскольку это условие не соблюдается то мы просто кладем 18 во временный стек

      Стек MAIN (  4, 39)
      Стек допстек (18)

2 шаг: temp = 4
        проверяем что допстек непустой и его вершина > temp
        поскольку это условие соблюдается и мы:
            - вершину из допстека перекладываем в основной
            - temp кладем в допстек

        temp = 4
      Стек MAIN (  39)
      Стек допстек (18)

      ->  Стек MAIN (  18, 39)
          Стек допстек (4)


3 шаг: temp = 18
        проверяем что допстек непустой и его вершина > temp
        поскольку это условие не соблюдается то мы:
            - temp кладем в допстек
        Стек MAIN (  39)
          Стек допстек (18, 4)

      ...

      4 шаг: temp = 39
              проверяем что допстек непустой и его вершина > temp
              поскольку это условие не соблюдается то мы:
                  - temp кладем в допстек
              Стек MAIN (  )
                Стек допстек (39, 18, 4)


public static Stack<Integer> sortStack(Stack<Integer> stack){
    Stack<Integer> tempStack = new Stack<>();

    while (!stack.empty()){

            int temp = stack.pop();

            while (!tempStack.empty() && tempStack.peek()>temp){
                stack.push(tempStack.pop());

            }

            tempStack.push(temp);
    }

    return tempStack;
    }
}

